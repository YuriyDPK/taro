"use client";

import { useState } from "react";
import { Button } from "@/shared/ui/button";
import { ChatMessage } from "@/types";
import { getTarotReadingStream } from "@/shared/api/gpt";
import { useRateLimits } from "@/shared/hooks/useRateLimits";

interface TarotChatProps {
  initialMessage?: string;
  className?: string;
  readingId?: string;
  onRateLimitExceeded?: (type: "message") => void;
}

export const TarotChat = ({
  initialMessage,
  className = "",
  readingId,
  onRateLimitExceeded,
}: TarotChatProps) => {
  const [messages, setMessages] = useState<ChatMessage[]>([
    {
      id: "welcome",
      text: "üåü –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é —Ç–µ–±—è, –¥–∏—Ç—è —Å–≤–µ—Ç–∞! –Ø –ê—Å—Ö–∞—Ç, —Ç–≤–æ—è –ø—Ä–æ–≤–æ–¥–Ω–∏—Ü–∞ –≤ –º–∏—Ä —Ç–∞–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∫–∞—Ä—Ç –¢–∞—Ä–æ. –†–∞—Å—Å–∫–∞–∂–∏ –º–Ω–µ, —á—Ç–æ —Ç—Ä–µ–≤–æ–∂–∏—Ç —Ç–≤–æ—é –¥—É—à—É, –∏ –∫–∞—Ä—Ç—ã –æ—Ç–∫—Ä–æ—é—Ç —Å–≤–æ–∏ —Å–µ–∫—Ä–µ—Ç—ã...",
      isUser: false,
      timestamp: Date.now(),
    },
  ]);

  const [currentMessage, setCurrentMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const { canSendMessage, registerMessage } = useRateLimits();

  const sendMessage = async () => {
    if (!currentMessage.trim() || isLoading) return;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å readingId
    if (readingId && !canSendMessage(readingId)) {
      onRateLimitExceeded?.("message");
      return;
    }

    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      text: currentMessage,
      isUser: true,
      timestamp: Date.now(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setCurrentMessage("");
    setIsLoading(true);

    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ª–∏–º–∏—Ç–∞—Ö
    if (readingId) {
      registerMessage(readingId);
    }

    // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è GPT —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
    const contextMessage = initialMessage
      ? `${initialMessage}\n\n–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${currentMessage}`
      : currentMessage;

    // –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≥–∞–¥–∞–ª–∫–∏ –¥–ª—è —Å—Ç—Ä–∏–º–∞
    const gptMessageId = `gpt-${Date.now()}`;
    const gptMessage: ChatMessage = {
      id: gptMessageId,
      text: "",
      isUser: false,
      timestamp: Date.now(),
    };

    setMessages((prev) => [...prev, gptMessage]);

    try {
      await getTarotReadingStream(contextMessage, (chunk: string) => {
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === gptMessageId
              ? { ...msg, text: (msg.text || "") + chunk }
              : msg
          )
        );
      });
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞:", error);
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === gptMessageId
            ? {
                ...msg,
                text: "üåô –ü—Ä–æ—Å—Ç–∏—Ç–µ, —ç–Ω–µ—Ä–≥–∏—è –Ω–∞—Ä—É—à–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ...",
              }
            : msg
        )
      );
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div
      className={`bg-black/40 backdrop-blur-sm border border-purple-400/30 rounded-lg flex flex-col ${className}`}
    >
      {/* –ó–∞–≥–æ–ª–æ–≤–æ–∫ —á–∞—Ç–∞ */}
      <div className="border-b border-purple-400/30 p-4">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-full bg-gradient-to-br from-purple-600 to-indigo-600 flex items-center justify-center text-white text-lg">
            üîÆ
          </div>
          <div>
            <div className="text-white font-medium">–ê—Å—Ö–∞—Ç</div>
            <div className="text-purple-300 text-sm">–¢–∞—Ä–æ –≥–∞–¥–∞–ª–∫–∞</div>
          </div>
        </div>
      </div>

      {/* –°–æ–æ–±—â–µ–Ω–∏—è */}
      <div className="max-h-96 min-h-32 overflow-y-auto p-4 space-y-4 flex-1">
        {messages.map((message) => (
          <div
            key={message.id}
            className={`flex ${
              message.isUser ? "justify-end" : "justify-start"
            }`}
          >
            <div
              className={`
                max-w-xs lg:max-w-md px-4 py-2 rounded-lg text-sm
                ${
                  message.isUser
                    ? "bg-gradient-to-r from-purple-600 to-indigo-600 text-white"
                    : "bg-black/60 border border-purple-400/30 text-white"
                }
              `}
            >
              {message.text}
              {isLoading &&
                message.id === messages[messages.length - 1]?.id &&
                !message.isUser && (
                  <span className="inline-block w-2 h-4 bg-purple-400 ml-1 animate-pulse">
                    |
                  </span>
                )}
            </div>
          </div>
        ))}
      </div>

      {/* –ü–æ–ª–µ –≤–≤–æ–¥–∞ */}
      <div className="border-t border-purple-400/30 p-4">
        <div className="flex flex-col lg:flex-row items-center justify-center gap-4">
          <textarea
            value={currentMessage}
            onChange={(e) => setCurrentMessage(e.target.value)}
            onKeyDown={handleKeyPress}
            placeholder="–ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –≥–∞–¥–∞–ª–∫–µ..."
            className="flex-1 w-full lg:w-auto bg-black/60 border border-purple-400/30 rounded-lg px-3 py-2 text-white placeholder-purple-300/50 resize-none focus:outline-none focus:border-purple-400"
            rows={2}
            disabled={isLoading}
          />
          <Button
            onClick={sendMessage}
            disabled={!currentMessage.trim() || isLoading}
            className="px-6 py-2 "
          >
            {isLoading ? "..." : "–°–ø—Ä–æ—Å–∏—Ç—å"}
          </Button>
        </div>
      </div>
    </div>
  );
};
